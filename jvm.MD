# JVM内存与GC核心面试题及答案


## 一、JVM内存结构
### 1. JVM运行时数据区包含哪些部分？各部分的作用是什么？
**答案**：  
JVM运行时数据区包括5个部分：
- **程序计数器**：线程私有，记录当前线程执行的字节码指令地址（唯一不会OOM的区域）。
- **虚拟机栈**：线程私有，由栈帧组成（每个方法对应一个栈帧），存储局部变量表、操作数栈、动态链接、返回地址，用于方法调用和执行。
- **本地方法栈**：线程私有，类似虚拟机栈，但为Native方法（如C++实现的方法）提供服务。
- **堆**：线程共享，JVM中最大的内存区域，用于存储对象实例和数组，是GC的主要区域（分年轻代和老年代）。
- **方法区**：线程共享，存储类元信息（类结构、字段、方法）、常量、静态变量等（JDK8后为元空间，JDK7及以前为永久代）。


### 2. 各内存区域可能发生哪些OOM或溢出异常？请举例说明。
**答案**：
- **堆OOM（OutOfMemoryError: Java heap space）**：对象持续创建且无法回收（如`List<Object> list = new ArrayList<>(); while(true) list.add(new Object());`）。
- **虚拟机栈溢出**：
    - `StackOverflowError`：线程栈深度超过限制（如无终止递归：`public void recursion() { recursion(); }`）。
    - `OutOfMemoryError: unable to create new native thread`：创建过多线程，栈内存总占用超物理内存（如`while(true) new Thread(() -> {}).start();`）。
- **方法区/元空间OOM**：
    - JDK7永久代OOM（`OutOfMemoryError: PermGen space`）：类加载过多（如动态代理频繁生成类）。
    - JDK8+元空间OOM（`OutOfMemoryError: Metaspace`）：类元信息持续增长且未卸载（如依赖冲突导致类重复加载）。


### 3. JDK7的永久代（PermGen）与JDK8的元空间（Metaspace）有何区别？
**答案**：  
| 维度         | 永久代（PermGen）                | 元空间（Metaspace）              |  
|--------------|----------------------------------|----------------------------------|  
| 存储内容     | 类元信息+字符串常量池+静态变量    | 仅类元信息（字符串常量池移至堆）  |  
| 内存来源     | JVM堆的一部分                    | 本地内存（操作系统分配的内存）    |  
| 大小限制     | 默认有上限（易OOM），需通过`-XX:PermSize`/`MaxPermSize`调整 | 默认无上限（受物理内存限制），可通过`-XX:MetaspaceSize`/`MaxMetaspaceSize`限制 |  
| 回收机制     | 与堆GC联动，但回收效率低          | 独立回收，依赖元空间GC线程        |


### 4. 堆内存的分代划分是怎样的？默认比例和调整参数是什么？
**答案**：  
堆内存按对象存活周期分为：
- **年轻代**：存储新创建的对象，分为Eden区和两个Survivor区（From/To）。
    - 默认比例：Eden : Survivor From : Survivor To = 8:1:1（总年轻代中，Eden占80%，每个Survivor占10%）。
    - 调整参数：`-XX:SurvivorRatio=N`（Eden/Survivor，默认8）。
- **老年代**：存储存活时间长的对象（从年轻代晋升而来）。
    - 年轻代与老年代默认比例：1:2（年轻代占堆的1/3，老年代占2/3）。
    - 调整参数：`-XX:NewRatio=N`（老年代/年轻代，默认2）。


### 5. 虚拟机栈的栈帧由哪些部分组成？各部分的作用是什么？
**答案**：  
栈帧是方法调用的基本单元，包含4部分：
- **局部变量表**：存储方法参数和局部变量（如`int a = 1`中的`a`），容量以槽（Slot）为单位。
- **操作数栈**：执行字节码指令的临时数据区（如`i++`需先将值入栈，运算后出栈）。
- **动态链接**：指向运行时常量池的方法引用（将符号引用转换为直接引用）。
- **返回地址**：方法执行完毕后返回的位置（如调用者的下一条指令地址）。


## 二、垃圾判定算法
### 1. 引用计数法的原理是什么？存在什么缺陷？
**答案**：
- **原理**：为每个对象维护一个“引用计数器”，当对象被引用时计数器+1，引用失效时-1；当计数器=0时，标记为可回收对象。
- **缺陷**：无法解决**循环引用问题**（如对象A引用B，B引用A，两者计数器均为1，但实际无人使用，无法被回收），因此JVM未采用该算法。


### 2. 可达性分析算法的核心是什么？GC Roots包含哪些对象？
**答案**：
- **核心**：以“GC Roots”为起点，通过引用链遍历对象，**不可达的对象**被标记为可回收（需经历两次标记确认）。
- **GC Roots范围**：
    1. 虚拟机栈中引用的对象（如方法局部变量）。
    2. 方法区中类静态属性引用的对象（如`static Object obj = new Object()`）。
    3. 方法区中常量引用的对象（如`String s = "abc"`中的`"abc"`）。
    4. 本地方法栈中JNI（Native方法）引用的对象。


### 3. Java的四种引用类型有何区别？各适用于什么场景？
**答案**：  
| 引用类型       | 回收时机                          | 应用场景                          |  
|----------------|-----------------------------------|-----------------------------------|  
| 强引用         | 永不回收（OOM前不释放）           | 普通对象引用（`Object obj = new Object()`） |  
| 软引用         | 内存不足时回收（GC后仍内存不足）   | 缓存（如图片缓存，`SoftReference<Bitmap>`） |  
| 弱引用         | GC触发时立即回收                  | 临时关联（如`ThreadLocal`的key，`WeakHashMap`） |  
| 虚引用         | 任何时候都可能回收，仅用于跟踪回收  | 堆外内存回收通知（配合`ReferenceQueue`） |


## 三、GC核心算法
### 1. 标记-清除算法的执行流程、优缺点及适用场景是什么？
**答案**：
- **流程**：
    1. **标记**：通过可达性分析标记所有存活对象。
    2. **清除**：遍历堆内存，清除所有未标记（死亡）的对象。
- **优点**：无需移动对象，实现简单。
- **缺点**：
    - 产生**内存碎片**（死亡对象清除后留下不连续的空闲空间）。
    - 效率低（需全堆标记和清除）。
- **适用场景**：老年代（对象存活时间长，移动成本高）。


### 2. 标记-复制算法的执行流程、优缺点及适用场景是什么？
**答案**：
- **流程**：
    1. **标记**：标记所有存活对象。
    2. **复制**：将存活对象复制到新的内存空间（如Survivor To区）。
    3. **清空**：清空原内存空间（如Eden+Survivor From区）。
- **优点**：
    - 无内存碎片。
    - 效率高（仅复制存活对象）。
- **缺点**：浪费一半空间（需预留新空间）。
- **适用场景**：年轻代（对象存活率低，复制成本低，如Eden区到Survivor区的复制）。


### 3. 标记-整理算法的执行流程、优缺点及适用场景是什么？
**答案**：
- **流程**：
    1. **标记**：标记所有存活对象。
    2. **整理**：将存活对象向内存一端移动，集中排列。
    3. **清除**：清除边界外的死亡对象。
- **优点**：无内存碎片，空间利用率高。
- **缺点**：需移动对象，成本高（老年代对象大且多）。
- **适用场景**：老年代（配合标记-清除算法优化，平衡碎片与效率）。


### 4. 分代收集思想的核心是什么？为什么年轻代和老年代采用不同算法？
**答案**：
- **核心**：根据对象存活周期的不同，将堆划分为年轻代和老年代，采用不同GC算法，提升回收效率。
- **原因**：
    - **年轻代**：对象“朝生夕灭”（存活率<10%），适合**标记-复制算法**（复制少量存活对象，效率高）。
    - **老年代**：对象存活时间长（存活率>90%），适合**标记-清除/整理算法**（避免频繁复制的高成本，平衡碎片与效率）。


## 四、经典垃圾回收器
### 1. Serial GC、Parallel Scavenge、Parallel Old的特点及适用场景是什么？
**答案**：  
| 回收器           | 特点                                  | 适用场景                          |  
|------------------|---------------------------------------|-----------------------------------|  
| Serial GC        | 单线程回收，STW时间长；简单高效，内存占用低 | 客户端应用（如桌面程序）、小内存设备（<1GB） |  
| Parallel Scavenge | 多线程回收年轻代，关注**吞吐量**（用户时间/(用户时间+GC时间)） | 服务端批处理（如数据计算）、对延迟不敏感的场景 |  
| Parallel Old     | 多线程回收老年代，标记-整理算法；配合Parallel Scavenge实现全并行 | 同上，JDK8默认组合（Parallel Scavenge+Parallel Old） |


### 2. CMS回收器的执行流程是什么？各阶段是否会STW？
**答案**：  
CMS（Concurrent Mark Sweep）是低延迟回收器，流程分4阶段：
1. **初始标记**：STW（Stop-The-World），标记GC Roots直接引用的对象（耗时短）。
2. **并发标记**：无STW，遍历引用链，标记所有存活对象（与用户线程并行）。
3. **重新标记**：STW，修正并发标记期间因用户线程操作导致的“漏标”对象（耗时比初始标记长，但远短于并发标记）。
4. **并发清除**：无STW，清除死亡对象（与用户线程并行）。


### 3. CMS的三色标记过程是什么？如何解决“漏标”问题？
**答案**：
- **三色标记**：用三种颜色标记对象状态：
    - 白色：未标记（初始状态）。
    - 灰色：已标记，但子对象未处理完毕。
    - 黑色：已标记，且子对象处理完毕（存活对象）。
- **漏标问题**：并发标记时，用户线程可能修改引用链（如黑色对象失去对白色对象的引用，灰色对象获得该引用），导致白色对象被误判为死亡。
- **解决方式**：**Incremental Update（增量更新）**：当黑色对象失去对白色对象的引用时，记录该引用变更，重新标记阶段处理这些记录，确保白色对象被正确标记。


### 4. G1回收器的核心特性及执行流程是什么？与CMS相比有何优势？
**答案**：
- **核心特性**：
    - 区域化分代：堆划分为多个大小相等的Region（1MB~32MB），每个Region可动态标记为Eden、Survivor、老年代。
    - MIXED GC：优先回收“垃圾比例高”的Region，平衡回收效率与延迟。
    - 可控延迟：通过`-XX:MaxGCPauseMillis`设置目标延迟（默认200ms）。
- **执行流程**：初始标记（STW）→并发标记→最终标记（STW）→筛选回收（STW，选择垃圾多的Region回收）。
- **相比CMS的优势**：
    - 无内存碎片（筛选回收时会整理对象）。
    - 支持大堆（数十GB），CMS在大堆下STW时间长。
    - 兼顾吞吐量与延迟，适用场景更广。


### 5. ZGC（JDK11+）的核心技术及优势是什么？
**答案**：
- **核心技术**：
    - **着色指针**：将对象标记信息存储在指针的空闲位（64位系统），无需额外内存记录标记状态。
    - **读屏障**：加载对象时触发，处理指针着色信息，保证并发访问的正确性。
- **优势**：
    - 超低延迟（STW时间<10ms）。
    - 支持TB级内存（最大4TB）。
    - 堆大小动态变化时性能稳定。
- **适用场景**：超大规模服务、低延迟要求极高的场景（如金融交易、实时数据分析）。


## 五、GC相关核心机制
### 1. Minor GC、Major GC、Full GC的触发条件是什么？
**答案**：
- **Minor GC**：年轻代（Eden区）空间不足时触发，仅回收年轻代。
- **Major GC**：老年代空间不足时触发，主要回收老年代（可能伴随Minor GC）。
- **Full GC**：
    1. 老年代空间不足且Major GC后仍不足。
    2. 方法区/元空间满。
    3. 调用`System.gc()`（仅建议，JVM可忽略）。
    4. CMS晋升失败（Minor GC后存活对象需晋升老年代，但老年代空间不足）。
    5. G1的MIXED GC无法回收足够空间，触发Full GC。


### 2. 对象晋升老年代的规则有哪些？
**答案**：  
对象从年轻代晋升到老年代的3大规则：
1. **年龄阈值**：对象在Survivor区每次经历Minor GC后年龄+1，达阈值（默认15，`-XX:MaxTenuringThreshold`调整）时晋升。
2. **动态年龄判定**：Survivor区中“同一年龄的对象总和”超过该区一半，该年龄及以上的对象直接晋升。
3. **大对象直接进入**：超过阈值（`-XX:PretenureSizeThreshold`，如10MB）的大对象直接进入老年代（避免年轻代频繁复制）。


### 3. 卡表（Card Table）和记忆集（Remembered Set）的作用是什么？
**答案**：
- **记忆集**：抽象概念，记录“非收集区到收集区的引用”（如老年代到年轻代的引用），避免GC时全量扫描非收集区。
- **卡表**：记忆集的具体实现，将老年代划分为多个512字节的“卡页”，用一个字节数组标记卡页状态：
    - 卡页中存在老年代到年轻代的引用时，标记为“脏卡”。
    - Minor GC时仅扫描“脏卡”对应的老年代区域，无需扫描整个老年代，提升效率。


### 4. 安全点（Safepoint）与安全区域（Safe Region）的作用是什么？
**答案**：
- **安全点**：线程暂停的“合法位置”（如方法返回、循环结束、异常抛出），GC时所有线程必须到达安全点才能暂停（避免线程执行到一半被中断，导致数据不一致）。
- **安全区域**：解决线程阻塞时无法到达安全点的问题（如Sleep、Wait状态），线程进入阻塞前标记自己处于“安全区域”，GC时无需等待该线程，恢复后检查GC是否完成。


## 六、GC日志与调优
### 1. 如何开启GC日志？关键日志指标有哪些？
**答案**：
- **开启参数**：
  ```bash
  -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:gc.log
  ```  
- **关键指标**：
    - GC类型（`GC`/`Full GC`/`G1 GC`）。
    - 回收区域（如`[Eden: 100M->0M(200M)]`表示Eden区从100M回收至0M，总容量200M）。
    - 回收前后内存变化（堆/年轻代/老年代的used和total）。
    - 耗时（`0.123ms`，STW时间）。


### 2. 常用的JVM内存参数和回收器参数有哪些？
**答案**：
- **内存参数**：
    - 堆大小：`-Xms2G`（初始堆）、`-Xmx2G`（最大堆，建议与-Xms一致）。
    - 年轻代：`-Xmn512M`（年轻代大小）、`-XX:SurvivorRatio=8`（Eden/Survivor）。
    - 老年代：`-XX:NewRatio=2`（老年代/年轻代）。
    - 元空间：`-XX:MetaspaceSize=256M`、`-XX:MaxMetaspaceSize=512M`。
- **回收器参数**：
    - Serial GC：`-XX:+UseSerialGC`。
    - Parallel GC：`-XX:+UseParallelGC`（年轻代）+`-XX:+UseParallelOldGC`（老年代）。
    - CMS：`-XX:+UseConcMarkSweepGC`+`-XX:+UseParNewGC`（年轻代并行）。
    - G1：`-XX:+UseG1GC`+`-XX:MaxGCPauseMillis=100`（目标延迟）。


### 3. GC调优的目标是什么？不同目标的配置策略有哪些？
**答案**：
- **调优目标**：
    1. **吞吐量优先**：最大化用户代码执行时间占比（如批处理任务）。
    2. **延迟优先**：最小化GC的STW时间（如高并发接口）。
- **配置策略**：
    - 吞吐量优先：
        - 选Parallel Scavenge+Parallel Old。
        - 增大堆大小（减少GC频率）：`-Xms8G -Xmx8G -Xmn2G`。
        - 调整吞吐量目标：`-XX:GCTimeRatio=19`（允许GC时间占比5%）。
    - 延迟优先：
        - 选G1/ZGC。
        - 控制堆大小（避免过大堆导致STW时间长）：`-Xms4G -Xmx4G`。
        - G1参数：`-XX:MaxGCPauseMillis=50`+`-XX:G1HeapRegionSize=16M`（Region大小影响延迟）。


### 4. 如何解决Minor GC频繁、Full GC频繁、CMS晋升失败等问题？
**答案**：
- **Minor GC频繁**：
    - 原因：年轻代过小，对象快速占满Eden区。
    - 解决：增大年轻代（`-Xmn`调大），避免大对象频繁分配（检查是否有短期大对象）。

- **Full GC频繁**：
    - 原因：老年代内存泄漏（对象未回收）、大对象过多。
    - 解决：
        - 排查内存泄漏（用MAT分析堆快照，定位长期存活的无用对象）。
        - 调大老年代（`-Xmx`调大，或调整`-XX:NewRatio`减小年轻代占比）。

- **CMS晋升失败**：
    - 原因：Minor GC后存活对象需晋升老年代，但老年代空间不足。
    - 解决：
        - 调大老年代或年轻代（减少晋升压力）。
        - 降低CMS触发阈值（`-XX:CMSInitiatingOccupancyFraction=70`，默认92%），让CMS提前回收老年代。


## 七、内存泄漏与排查
### 1. 什么是内存泄漏？常见的内存泄漏场景有哪些？
**答案**：
- **定义**：对象不再被使用但无法被GC回收，导致内存占用持续增长，最终引发OOM。
- **常见场景**：
    1. 静态集合持有对象（如`static List<Object> list = new ArrayList<>();`，添加对象后未清除）。
    2. 未关闭的资源（如`InputStream`、数据库连接未在`finally`中关闭）。
    3. 监听器/回调未移除（如注册的事件监听器未注销，导致对象被容器持续引用）。
    4. ThreadLocal未清理（线程池复用线程时，`ThreadLocal`的value未`remove()`，导致随线程长期存活）。


### 2. 如何排查内存泄漏？请描述工具和流程。
**答案**：
- **工具链**：`jmap`（生成堆快照）、MAT（Memory Analyzer Tool，分析快照）、`jstat`（监控GC状态）。
- **排查流程**：
    1. **监控异常**：用`jstat -gc <pid> 1000`监控GC频率和内存变化，确认是否有内存泄漏（如老年代used持续增长）。
    2. **生成快照**：`jmap -dump:format=b,file=heap.hprof <pid>`（OOM时可自动生成：`-XX:+HeapDumpOnOutOfMemoryError`）。
    3. **分析快照**：用MAT打开`heap.hprof`，通过“Leak Suspects”报告定位泄漏对象（如大量`User`对象）。
    4. **追踪引用链**：在MAT中查看泄漏对象的“Dominator Tree”，找到持有对象的根引用（如静态List），定位代码中的泄漏点。
    5. **修复验证**：修改代码（如清除静态集合、关闭资源），重新部署后用`jstat`确认内存是否稳定。  
