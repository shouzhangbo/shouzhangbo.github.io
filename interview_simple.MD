### **Java中高级开发工程师面试题与答案总结（数据结构与算法篇）**

#### **一、 Java基础**

**1. 谈谈你对封装、继承、多态的理解**

*   **答案**：
    *   **封装**： 将数据（属性）和行为（方法）包装在一起，隐藏内部实现细节，仅对外提供可控的访问接口。核心目的是**提高代码的安全性、可维护性和可复用性**。例如，使用`private`修饰字段，提供公共的`getter/setter`方法。
    *   **继承**： 子类（派生类）继承父类（基类）的属性和方法，实现代码的复用。表示的是 `is-a` 关系。但需要注意，**过度使用继承会导致代码耦合度高，应遵循“组合优于继承”的原则**。   
    *   **多态**： 同一操作作用于不同的对象，可以有不同的执行结果。主要包括：
        *   **编译时多态（静态绑定）**： 通过**方法重载（Overload）** 实现。
        *   **运行时多态（动态绑定）**： 通过**方法重写（Override）** 实现，这是OOP的核心。底层机制是JVM的**方法调用指令（如`invokevirtual`）** 和**方法表**。例如：`Animal a = new Dog(); a.sound();` 会调用`Dog`类的`sound`方法。

**2. Java类初始化顺序（静态代码块、实例代码块、构造器）**

*   **答案**： 初始化顺序遵循以下原则：
    1.  **父类静态** -> **子类静态** -> **父类实例** -> **父类构造** -> **子类实例** -> **子类构造**。
    2.  具体步骤：
        *   加载类时，先初始化父类的**静态变量**和**静态代码块**（按代码书写顺序）。
        *   然后初始化子类的**静态变量**和**静态代码块**（按代码书写顺序）。
        *   创建对象时，先初始化父类的**实例变量**和**实例代码块**（按代码书写顺序）。
        *   执行父类的**构造器**。
        *   初始化子类的**实例变量**和**实例代码块**（按代码书写顺序）。
        *   执行子类的**构造器**。
    *   **关键点**： `static`部分只在类首次加载时初始化一次；父类优先于子类；静态优先于实例；变量和代码块按顺序，构造器最后执行。

**3. 面试题：父类可以访问子类的成员变量吗？子类可以访问父类的成员变量吗？有什么限制？**

*   **答案**：
    *   **父类访问子类成员变量：不可行。**
        *   在继承关系中，父类对子类一无所知。父类的代码在编译时就已经确定，而子类可能还未定义。因此，**父类无法直接访问子类特有的成员变量**。父类只能访问自己定义的成员（包括`private`成员，但通常通过公共方法访问）和继承链上层的成员。
        *   **原理**： 引用类型决定了编译时能访问哪些成员。一个`Parent`类型的引用（即使它指向一个`Child`对象）在编译期只能看到`Parent`类中定义的成员。

    *   **子类访问父类成员变量：可行，但有访问权限限制。**
        *   子类继承父类，自然可以访问父类的成员，但受限于访问修饰符：
            *   **`public`**： 任何地方都可以访问。
            *   **`protected`**： 子类（即使在不同包）可以访问。
            *   **`默认（包访问权限）`**： 只有同包下的子类可以访问。
            *   **`private`**： **子类不能直接访问**。必须通过父类提供的公共方法（如getter/setter）来间接访问。
    *   **示例与陷阱**：
        ```java
        class Parent {
            public String publicField = "Parent Public";
            protected String protectedField = "Parent Protected";
            private String privateField = "Parent Private"; // 子类无法直接访问
            String defaultField = "Parent Default"; // 包访问权限
        }

        class Child extends Parent {
            public String childField = "Child Field";

            public void accessFields() {
                System.out.println(publicField);    // OK
                System.out.println(protectedField); // OK
                // System.out.println(privateField); // 编译错误！
                System.out.println(defaultField);   // OK (如果在同一包内)
                System.out.println(childField);     // OK
            }
        }

        public class Test {
            public static void main(String[] args) {
                Parent parentRef = new Child();
                System.out.println(parentRef.publicField); // OK，访问的是Parent的字段
                // System.out.println(parentRef.childField); // 编译错误！Parent类型看不到childField
            }
        }
        ```


**3. 详细说明抽象类和接口的区别，以及在JDK 8之后有什么变化？**

*   **答案**： 这是考察OOP设计思想的经典问题。

| 特性 | 抽象类 (Abstract Class) | 接口 (Interface) |
| :--- | :--- | :--- |
| **定义关键字** | `abstract class` | `interface` |
| **成员变量** | 可以是任意类型的变量（包括非静态、非final） | **默认是 `public static final` 的常量** |
| **方法实现** | 可以包含**抽象方法**（无实现）和**具体方法**（有实现） | **JDK 8前**：只能有抽象方法。<br>**JDK 8+**：可以有 **`default`方法** 和 **`static`方法**。<br>**JDK 9+**：可以有 **`private`方法**。 |
| **构造方法** | **有构造方法**，用于子类实例化时初始化抽象类中定义的状态。 | **没有构造方法**，不能实例化。 |
| **继承方式** | 类使用 **`extends`** 关键字继承抽象类。**Java是单继承**，一个类只能继承一个抽象类。 | 类使用 **`implements`** 关键字实现接口。一个类可以**实现多个接口**。接口可以**继承多个接口**（`extends Interface1, Interface2`）。 |
| **设计目的** | 表示一种 **"is-a"** 关系。是对一类事物的**本质抽象**，代码复用的核心。例如：`Animal`是一个抽象类，`Dog`和`Cat`继承它。 | 表示一种 **"has-a"** 或 **"can-do"** 关系。是对**行为**或**能力**的契约定义。例如：`Flyable`、`Serializable`。 |
| **访问修饰符** | 方法可以使用`public`, `protected`, `private`等。 | 接口中的方法**默认是`public`**的（包括`default`方法），不能使用`private`（JDK9的`private`方法除外）和`protected`。 |

*   **JDK 8 的核心变化**： 接口引入了`default`方法，其主要目的是**为了接口的演化**。当需要给一个被广泛实现的接口添加新方法时，如果不使用`default`，所有实现类都必须修改，否则会编译错误。使用`default`方法可以提供默认实现，实现类无需修改即可继承该实现。
*   **如何选择**：
    *   如果需要定义**模板方法**，包含一些状态的初始化，或者代码复用性很强，关系是"is-a"，用**抽象类**。
    *   如果需要定义**行为契约**，希望类具备多种不同的能力，或者关系是"can-do"，用**接口**。**现代Java开发更推崇"组合优于继承"，倾向于使用接口**。


**4. `extends`和`implements`关键字在用法和含义上有什么区别？**

*   **答案**：
    *   **`extends`（继承）**：
        *   **用于类继承类**： `class Child extends Parent {}`。表示"是一个"的关系，子类获得父类的属性和方法（受访问权限控制）。**Java不支持多重继承，一个类只能`extends`一个父类**。
        *   **用于接口继承接口**： `interface NewInterface extends OldInterface1, OldInterface2 {}`。表示新接口继承了旧接口的抽象方法、默认方法和常量。**接口支持多重继承**。

    *   **`implements`（实现）**：
        *   **用于类实现接口**： `class MyClass implements Interface1, Interface2 {}`。表示"具有...能力"的关系，类承诺要提供接口中所有抽象方法的具体实现（除非这个类本身是抽象的）。**一个类可以实现多个接口**。

    *   **核心区别总结**：
        *   `extends` 用于建立**继承关系**，重点是**代码和状态的复用**。
        *   `implements` 用于建立**实现关系**，重点是**履行行为契约**。
        *   一个类可以同时使用两者：`class MyClass extends ParentClass implements Interface1, Interface2 {}`


**5. `==` 和 `equals()` 的区别？**

*   **答案**：
    *   **`==`**： 是**运算符**。
        *   用于比较**基本数据类型**时，比较的是它们的**值**是否相等。
        *   用于比较**引用数据类型**时，比较的是两个引用是否指向**堆内存中的同一个对象**（即内存地址是否相同）。
    *   **`equals()`**： 是`Object`类的一个**方法**。默认实现就是`==`，即比较内存地址。
        *   但很多类（如`String`、`Integer`等）**重写（Override）** 了`equals()`方法，使其比较的是对象的**内容**（或逻辑状态）是否相等。
        *   **重写`equals()`的规范**： 自反性、对称性、传递性、一致性、与非空对象比较返回false。
    *   **关键点**： **重写`equals()`时必须重写`hashCode()`**，以保证相等的对象具有相等的哈希码，这是`HashMap`等集合类正常工作的基础。

**6. 面试题：`String`, `StringBuilder`, `StringBuffer` 的区别？**

*   **答案**：
    *   **`String`**： **不可变（Immutable）** 字符序列。任何修改操作（如`concat`, `substring`）都会产生一个新的`String`对象。**线程安全**。
    *   **`StringBuilder`**： **可变**字符序列。提供`append`, `insert`, `delete`等方法来修改自身内容。**非线程安全**，但**性能最高**。适用于单线程场景。
    *   **`StringBuffer`**： **可变**字符序列。方法与`StringBuilder`类似，但所有公共方法都由**`synchronized`** 修饰，是**线程安全**的。因为同步开销，性能低于`StringBuilder`。
    *   **使用场景**：
        *   字符串不经常改变：用`String`。
        *   单线程下字符串频繁拼接/修改：用`StringBuilder`。
        *   多线程下字符串频繁拼接/修改：用`StringBuffer`。

**7. final`, `finally`, `finalize` 的区别？**

*   **答案**：
    *   **`final`**： 是**修饰符**。
        *   修饰**类**： 类不能被继承（如`String`）。
        *   修饰**方法**： 方法不能被重写。
        *   修饰**变量**： 变量一旦初始化就不能再改变（对于基本类型，值不能变；对于引用类型，引用指向的地址不能变，但对象内部的状态可以变）。
    *   **`finally`**： 是**异常处理关键字**。与`try-catch`一起使用，`finally`块中的代码**无论是否发生异常都会执行**（除非JVM退出），常用于释放资源（如关闭文件流、数据库连接）。
    *   **`finalize()`**： 是`Object`类的一个**方法**。当垃圾回收器（GC）决定回收某个对象时，会在回收之前调用它的`finalize()`方法。**此方法不稳定且不推荐使用**，因为调用时机不确定，容易导致性能问题和资源泄漏。现代Java使用`try-with-resources`和`Cleaner`等机制来管理资源。

#### **1. 包装类型（Wrapper Classes）**

**面试题：什么是包装类型？为什么需要包装类型？自动装箱和拆箱是什么？有什么需要注意的？**

*   **答案**：
    *   **什么是包装类型**： Java为8种基本数据类型提供了对应的**引用类型**，这些类称为包装类型。
        *   `byte` -> `Byte`
        *   `short` -> `Short`
        *   `int` -> `Integer`
        *   `long` -> `Long`
        *   `float` -> `Float`
        *   `double` -> `Double`
        *   `char` -> `Character`
        *   `boolean` -> `Boolean`
    *   **为什么需要包装类型**：
        1.  **泛型要求**： Java的泛型在编译后会进行**类型擦除**，其类型参数会被替换为`Object`。而基本数据类型不是对象，无法作为泛型参数。例如，`List<int>`是不合法的，必须使用`List<Integer>`。
        2.  **null值表示**： 基本数据类型有默认值（如`int`默认为0），无法表示"空"或"缺失"的概念。包装类型可以是`null`。
        3.  **面向对象操作**： 包装类型提供了许多有用的方法，如`Integer.parseInt(String)`，`Character.isDigit(char)`等。
        4.  **集合框架存储**： 所有集合类（如`ArrayList`, `HashMap`）都只能存储对象，不能存储基本数据类型。

    *   **自动装箱（Auto-boxing）和自动拆箱（Auto-unboxing）**：
        *   **自动装箱**： 在需要包装类型对象的地方，如果使用的是基本数据类型，编译器会自动将其转换为对应的包装类型。
            ```java
            Integer i = 10; // 编译器自动转换为：Integer i = Integer.valueOf(10);
            List<Integer> list = new ArrayList<>();
            list.add(1); // 自动装箱：list.add(Integer.valueOf(1));
            ```
        *   **自动拆箱**： 在需要基本数据类型的地方，如果使用的是包装类型对象，编译器会自动将其转换为对应的基本数据类型。
            ```java
            Integer i = new Integer(10);
            int j = i; // 自动拆箱：int j = i.intValue();
            if (i > 5) { // 自动拆箱：if (i.intValue() > 5)
                // ...
            }
            ```
    *   **注意事项（陷阱）**：
        1.  **空指针异常（NPE）**： 自动拆箱时，如果包装类对象为`null`，会抛出`NullPointerException`。
            ```java
            Integer nullInt = null;
            int num = nullInt; // 运行时抛出 NullPointerException！
            ```
        2.  **性能开销**： 装箱和拆箱会创建额外的对象，在循环或性能敏感的代码中大量使用可能会影响性能。
        3.  **缓存问题**： 包装类有缓存机制（如`Integer`缓存-128到127）。在这个范围内，`valueOf`返回的是缓存对象，用`==`比较可能为`true`，但范围外会创建新对象，`==`比较为`false`。**永远使用`equals()`来比较包装类对象的值**。
            ```java
            Integer a = 127;
            Integer b = 127;
            System.out.println(a == b); // true (在缓存范围内)

            Integer c = 128;
            Integer d = 128;
            System.out.println(c == d); // false (超出缓存范围，是新对象)
            System.out.println(c.equals(d)); // true (比较值)
            ```

#### **2. `static`关键字的作用**

**面试题：`static`关键字可以修饰哪些成员？它们有什么特点？静态方法为什么不能调用非静态成员？**

*   **答案**：
    *   **`static`可以修饰**： 变量、方法、代码块、内部类。
    *   **特点**：
        *   **属于类，而非对象**： 静态成员在**类加载**时就被初始化，内存中只有一份，被该类的所有实例共享。
        *   **可以通过类名直接访问**： 无需创建对象，例如`Math.PI`, `Arrays.sort()`。
        *   **生命周期长**： 静态成员的生命周期与类相同，从类加载开始，到JVM结束。
    *   **静态方法不能调用非静态成员的原因**：
        *   静态方法在类加载时就可以通过类名调用，此时可能**还没有创建任何对象**。而非静态成员（实例变量、实例方法）依赖于对象的存在，必须通过对象来访问。因此，在静态方法内部直接访问非静态成员在逻辑上是矛盾的，会导致编译错误。
        *   **反之，非静态方法可以访问静态成员**，因为非静态方法调用时，类肯定已经被加载，静态成员已经存在。

#### **3. 编译时异常（Checked Exception）和运行时异常（Runtime Exception/Unchecked Exception）的区别**

**面试题：请说明编译时异常和运行时异常的区别，并举例说明。**

*   **答案**：
    *   **编译时异常（Checked Exception）**：
        *   **定义**： 继承自`Exception`但不继承`RuntimeException`的异常。
        *   **处理要求**： **必须被处理**。编译器会检查，如果代码可能抛出这类异常，要么用`try-catch`块捕获，要么在方法签名上用`throws`声明抛出，否则编译不通过。
        *   **设计目的**： 表示程序可以**预期**并应该**恢复**的错误情况，通常与外部资源有关（如文件不存在、网络中断）。
        *   **例子**： `IOException`, `SQLException`, `ClassNotFoundException`。
    *   **运行时异常（Unchecked Exception）**：
        *   **定义**： 继承自`RuntimeException`的异常。
        *   **处理要求**： **不强制要求处理**。编译器不检查是否对这类异常进行了处理。
        *   **设计目的**： 表示程序员的**编程错误**或逻辑错误，通常是不可恢复的。例如空指针、数组越界、类型转换错误。
        *   **例子**： `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ClassCastException`, `IllegalArgumentException`。
    *   **错误（Error）**： 是`Throwable`的另一个子类，表示系统级错误，应用程序通常无法处理，如`OutOfMemoryError`, `StackOverflowError`。

#### **4. `final`关键字的作用（补充）**

**面试题：`final`关键字可以修饰什么？分别有什么效果？**

*   **答案**：
    *   **修饰变量**：
        *   如果是**基本类型**，其**值**一旦初始化就不能再改变（常量）。
        *   如果是**引用类型**，其**引用指向的地址**不能改变，但**对象内部的状态（属性）可以改变**。
        *   `final`成员变量必须在**声明时初始化**或在**所有构造器结束前完成初始化**。
    *   **修饰方法**： 该方法**不能被子类重写（Override）**。可以防止继承类修改其行为。
    *   **修饰类**： 该类**不能被继承**。例如`String`类就是`final`的，保证了字符串的不可变性和安全性。

#### **5. 重写（Override）和重载（Overload）的区别（补充）**

**面试题：详细说明方法重写和方法重载的区别。**

*   **答案**：
    | 方面 | 重写 (Override) | 重载 (Overload) |
    | :--- | :--- | :--- |
    | **发生位置** | **父子类**之间 | **同一个类**中 |
    | **方法签名** | **必须完全相同**（方法名、参数列表） | **必须不同**（参数列表的类型、个数、顺序至少有一个不同） |
    | **返回类型** | 返回类型**必须相同或是其子类**（协变返回类型） | 可以不同 |
    | **访问修饰符** | 子类方法的访问权限**不能比父类更严格**（例如，父类`protected`，子类不能是`private`） | 可以不同 |
    | **异常抛出** | 子类方法抛出的异常**不能比父类更广泛**（只能是父类异常或其子类） | 可以不同 |
    | **设计目的** | 实现**运行时多态**，子类可以根据需要实现特定行为 | 提供处理不同类型数据的**同名方法**，增加可读性 |

#### **6. 字符流和字节流的区别**

**面试题：Java IO中，字符流和字节流有什么区别？它们的基类是什么？如何选择？**

*   **答案**：
    *   **字节流**：
        *   **基类**： `InputStream` 和 `OutputStream`。
        *   **操作单位**： 以**字节（byte, 8bit）** 为单位进行读写。
        *   **用途**： 可以处理**所有类型**的文件（图片、视频、可执行文件、文本文件等），因为计算机中所有数据最终都是以字节形式存储的。
    *   **字符流**：
        *   **基类**： `Reader` 和 `Writer`。
        *   **操作单位**： 以**字符（char, 16bit）** 为单位进行读写。
        *   **用途**： 专门用于处理**文本文件**。字符流在读写时会自动进行**字符编码和解码**，解决了字节流直接操作文本时可能出现的乱码问题。
    *   **如何选择**：
        *   复制图片、视频等**二进制文件**，必须使用**字节流**。
        *   读写**文本文件**，推荐使用**字符流**，以避免乱码，更高效。
        *   有时可以**组合使用**，例如用字节流读取文件，再用`InputStreamReader`（转换流）指定字符集转换为字符流处理。

#### **7. `this`和`super`关键字的作用**

**面试题：解释`this`和`super`关键字的作用和用法。**

*   **答案**：
    *   **`this`关键字**： 代表**当前对象的引用**。
        *   **用法1**： 区分同名的实例变量和局部变量。`this.name = name;`
        *   **用法2**： 在构造器中调用本类的其他构造器。`this(...);` **必须放在构造器第一行**。
        *   **用法3**： 作为参数传递，将当前对象传递给其他方法。
    *   **`super`关键字**： 代表**直接父类对象的引用**。
        *   **用法1**： 访问父类中被隐藏或重写的成员（变量或方法）。`super.methodName();`
        *   **用法2**： 在子类构造器中调用父类的构造器。`super(...);` **必须放在子类构造器第一行**。如果子类构造器没有显式调用，编译器会默认调用`super();`（父类无参构造器）。

#### **8. `try-catch-finally`的执行顺序和`finally`的特点**

**面试题：说明`try-catch-finally`语句块的执行顺序。`finally`块一定会执行吗？如果在`try`或`catch`中遇到`return`，`finally`还会执行吗？**

*   **答案**：
    *   **执行顺序**：
        1.  执行`try`块中的代码。
        2.  如果没有异常发生，跳过所有`catch`块，执行`finally`块。
        3.  如果`try`块中发生异常，立即跳转到匹配的`catch`块执行，然后执行`finally`块。
        4.  如果异常在`catch`块中没有被处理（或又抛出新异常），在执行完`finally`块后，异常会继续向外抛出。
    *   **`finally`的特点**：
        *   **`finally`块通常用于释放资源**（如关闭文件流、数据库连接），保证资源总能被释放，避免资源泄漏。
        *   **`finally`块几乎总是会执行**。即使在`try`或`catch`块中遇到了`return`、`break`、`continue`等语句，`finally`块也会在方法返回或循环跳出**之前**被执行。
        *   **唯一不执行`finally`的情况**： 在`try`或`catch`块中调用了`System.exit(int)`（终止JVM），或者所在线程被杀死，或者CPU断电。
    *   **`return`与`finally`的经典问题**：
        ```java
        public int testFinally() {
            try {
                System.out.println("try block");
                return 1; // 1. 计算返回值1，暂存。
            } catch (Exception e) {
                return 2;
            } finally {
                System.out.println("finally block");
                // 2. 执行finally块。如果finally里有return，会覆盖之前的返回值。
                // return 3; // 如果取消注释，方法最终返回3！
            }
            // 3. 将暂存的返回值1返回。
        }
        // 输出： try block -> finally block -> 返回值: 1
        ```

#### **9. 基本数据类型和引用数据类型的区别**

**面试题：简述Java中基本数据类型和引用数据类型的区别。**

*   **答案**：
    | 方面 | 基本数据类型 (Primitive Types) | 引用数据类型 (Reference Types) |
    | :--- | :--- | :--- |
    | **存储内容** | 直接存储**数据值** | 存储的是对象的**内存地址（引用）** |
    | **内存分配** | 在**栈**上分配（如果是局部变量） | 对象在**堆**上分配，引用变量在栈上 |
    | **默认值** | 有默认值（如`int`为0，`boolean`为false） | 默认值为`null` |
    | **传递方式** | **按值传递**（传递的是值的拷贝） | **按引用传递的地址值**（传递的是地址的拷贝，双方指向同一个对象） |
    | **示例** | `int a = 10;` | `String str = "hello";` `Object obj = new Object();` |

#### **10. 缓冲流（Buffered Streams）**

**面试题：什么是缓冲流？使用缓冲流有什么好处？**

*   **答案**：
    *   **什么是缓冲流**： 缓冲流是**装饰器模式**的典型应用，它们"包装"在基本的字节流或字符流之上，内部维护了一个**缓冲区（默认通常是8KB）**。例如：`BufferedInputStream`, `BufferedOutputStream`, `BufferedReader`, `BufferedWriter`。
    *   **好处**：
        1.  **减少I/O操作次数，提高效率**： 普通的流每次读写一个字节/字符，这意味着对于一个大文件，需要进行成千上万次底层的系统调用，非常耗时。缓冲流会先将数据读入缓冲区，当缓冲区满了（或读完了）再一次性进行实际的I/O操作，将数据写入缓冲区，满了再一次性写出。这极大地减少了系统调用次数。
        2.  **提供了方便的API**： 例如，`BufferedReader`提供了`readLine()`方法，可以一次读取一行文本，非常方便。

#### **11. `String`, `StringBuffer`, `StringBuilder`的区别（补充）**

**面试题：解释`String`, `StringBuffer`和`StringBuilder`的区别，以及各自的适用场景。**

*   **答案**：
    | 特性 | `String` | `StringBuffer` | `StringBuilder` |
    | :--- | :--- | :--- | :--- |
    | **可变性** | **不可变** | **可变** | **可变** |
    | **线程安全** | **是**（因为不可变） | **是**（方法使用`synchronized`修饰） | **否** |
    | **性能** | 低（拼接会产生新对象） | 中（因线程安全开销） | **高** |
    | **适用场景** | 操作少量数据，或字符串值不经常改变 | **多线程**环境下大量字符串操作 | **单线程**环境下大量字符串操作（**首选**） |

#### **12. 修饰符的访问范围（访问控制符）**

**面试题：请说明Java中四种访问修饰符的访问范围。**

*   **答案**：
    | 修饰符 | 同类 | 同包 | 不同包的子类 | 不同包的非子类 |
    | :--- | :--- | :--- | :--- | :--- |
    | `private` | ✅ | ❌ | ❌ | ❌ |
    | `默认` (无修饰符) | ✅ | ✅ | ❌ | ❌ |
    | `protected` | ✅ | ✅ | ✅ | ❌ |
    | `public` | ✅ | ✅ | ✅ | ✅ |

    *   **设计原则**： 通常遵循"**最小访问权限原则**"，即一个类或成员如果不需要被外部访问，就应该将其访问权限设置得尽可能严格（如`private`），这是一种良好的封装实践。

---

#### **二、 Java数据结构和算法**

**1. ArrayList底层是数组，初始长度是多少？为什么设置这么长？怎么扩容？**

*   **答案**：
    *   **初始长度**： 在JDK8及以后，`ArrayList`的**默认初始容量是10**。这个容量指的是底层数组`elementData`的初始长度（在第一次添加元素时真正初始化为10）。
    *   **为什么是10**： 这是一个经验值，在**空间和时间效率之间取得了一个平衡**。设置太小会导致频繁扩容，影响性能；设置太大则会浪费内存空间。10是一个对中小规模数据集比较友好的初始值。
    *   **扩容机制**：
        1.  当调用`add`方法时，会检查当前元素数量是否等于底层数组长度。
        2.  如果相等，则需要扩容。新的容量计算规则为：`newCapacity = oldCapacity + (oldCapacity >> 1)`，即**大约为旧容量的1.5倍**（例如，10 -> 15, 15 -> 22）。
        3.  然后使用`Arrays.copyOf`方法创建一个新的数组，并将原数组的元素复制到新数组中。这是一个相对耗时的操作（O(n)时间复杂度）。

**2. LinkedList和ArrayList在查询和增删操作时优缺点是什么？**

*   **答案**：
    *   **底层结构**：
        *   `ArrayList`：基于**动态数组**，内存空间连续。
        *   `LinkedList`：基于**双向链表**，内存空间不连续，每个元素（节点）包含数据、指向前驱节点的引用和指向后继节点的引用。
    *   **性能对比**：
        | 操作 | ArrayList | LinkedList | 原因分析 |
        | :--- | :--- | :--- | :--- |
        | **随机访问（get/set）** | **O(1)**，极快 | **O(n)**，慢 | ArrayList通过索引直接计算内存地址；LinkedList需要从头或尾遍历。 |
        | **头部插入/删除（add/remove First）** | **O(n)**，慢 | **O(1)**，快 | ArrayList需要将后续所有元素向后/前移动；LinkedList只需修改两个节点的引用。 |
        | **尾部插入/删除（add/remove Last）** | **O(1)**，快（** amortized **，均摊时间复杂度） | **O(1)**，快 | ArrayList通常有预留空间，但扩容时是O(n)；LinkedList直接修改尾节点引用。 |
        | **中间插入/删除** | **O(n)**，慢 | **O(n)**，慢（但实际操作更快） | ArrayList需要移动元素；LinkedList需要遍历找到位置，但修改操作本身是O(1)。 |
    *   **总结与选型**：
        *   **`ArrayList`**： 适用于**查询操作非常频繁，增删操作主要发生在列表末尾**的场景。因其CPU缓存友好性，在实践中往往表现优于LinkedList。
        *   **`LinkedList`**： 适用于**频繁在列表头部或中间进行插入/删除操作，而查询操作很少**的场景。

**3. Stack和Queue区别是什么？**

*   **答案**：
    *   **Stack（栈）**：
        *   **数据结构**： **LIFO（Last-In-First-Out，后进先出）**，像是一个只有一个口的桶。
        *   **核心操作**： `push`（压栈）、`pop`（弹栈并返回栈顶元素）、`peek`（查看栈顶元素不移除）。
        *   **Java实现**： `Stack`类（基于Vector，已过时），更推荐使用`Deque`接口的实现（如`LinkedList`）来模拟栈：`Deque stack = new LinkedList<>();` 使用`push`/`pop`/`peek`。
    *   **Queue（队列）**：
        *   **数据结构**： **FIFO（First-In-First-Out，先进先出）**，像是排队。
        *   **核心操作**： `add`/`offer`（入队）、`remove`/`poll`（出队并返回队首元素）、`element`/`peek`（查看队首元素不移除）。
        *   **Java实现**： `LinkedList`, `PriorityQueue`, `ArrayDeque`。

**4. Hash冲突解决方案有哪些？优缺点是什么？**

*   **答案**： 当两个不同的键通过哈希函数计算出的数组索引（桶位置）相同时，就发生了哈希冲突。主要解决方案有：
    *   **1. 链地址法（Separate Chaining）**：
        *   **描述**： 将散列到同一桶的所有元素存储在一个**链表**（或红黑树）中。
        *   **优点**： 简单有效，易于实现；可以处理任意多的冲突。
        *   **缺点**： 如果链表过长，查询性能会退化为O(n)。需要额外的空间存储指针。
        *   **应用**： **Java的`HashMap`、`ConcurrentHashMap`**。
    *   **2. 开放定址法（Open Addressing）**：
        *   **描述**： 当发生冲突时，按照某种探测序列（如线性探测、平方探测）在数组中寻找下一个空闲的桶。
        *   **优点**： 所有数据都存储在数组中，**避免了指针带来的空间开销**，对CPU缓存更友好。
        *   **缺点**： 删除操作复杂（需要标记为已删除，而非直接置空）；容易产生**聚集现象**，导致性能下降；装载因子不能太高（通常<0.7）。
        *   **应用**： `ThreadLocalMap`。
    *   **3. 再哈希法（Rehashing）**：
        *   **描述**： 准备多个不同的哈希函数，当第一个哈希函数发生冲突时，使用第二个、第三个...直到找到空闲位置。
        *   **优点**： 不易产生聚集。
        *   **缺点**： 计算多个哈希值会增加时间成本。

**5. HashMap在JDK7和JDK8区别是什么？为什么增加了红黑树？红黑树为什么是平衡树？HashMap和Hashtable区别是什么？**

*   **答案**：
    *   **JDK7 vs JDK8的主要区别**：
        | 特性 | JDK7 | JDK8 |
        | :--- | :--- | :--- |
        | **底层结构** | 数组 + 链表 | 数组 + 链表 / **红黑树** |
        | **插入方式** | **头插法**（易产生死循环） | **尾插法** |
        | **Hash计算** | 扰动处理次数多，更复杂 | 扰动处理更简洁，性能稍好 |
        | **扩容后重哈希** | 所有元素重新计算位置 | 优化：元素位置要么不变，要么是`原位置 + oldCap` |

    *   **为什么增加红黑树**： 在极端情况下（例如劣质的哈希函数导致所有键都映射到同一个桶），链表会变得非常长，此时`get`操作的性能会从O(1)**退化为O(n)**。引入红黑树后，在链表长度超过阈值（默认8）且数组容量大于64时，将链表转换为红黑树，可以将查询性能**提升至O(log n)**，从而防止性能急剧下降。

    *   **红黑树为什么是平衡树**： 红黑树通过以下5条约束规则来保持**近似平衡**，从而保证最坏情况下的操作效率为O(log n)：
        1.  节点是红色或黑色。
        2.  根节点是黑色。
        3.  所有叶子节点（NIL）是黑色。
        4.  **红色节点的子节点必须是黑色**（即不能有两个连续的红色节点）。
        5.  从任一节点到其每个叶子节点的所有路径都包含**相同数量的黑色节点**（即黑色高度相同）。
            这些规则确保了从根到叶子的**最长可能路径不会超过最短可能路径的两倍**，从而实现了平衡。

    *   **HashMap vs Hashtable**：
        | 特性 | HashMap | Hashtable |
        | :--- | :--- | :--- |
        | **线程安全** | **非线程安全** | **线程安全**（方法使用`synchronized`修饰） |
        | **性能** | 高 | 低（因同步开销） |
        | **Null键/值** | **允许**一个`null`键和多个`null`值 | **不允许**`null`键或`null`值 |
        | **继承体系** | 继承`AbstractMap` | 继承`Dictionary`（已过时） |
        | **初始容量与扩容** | 默认16，扩容为2n | 默认11，扩容为2n+1 |

**6. HashMap怎么保证并发安全？**

*   **答案**： 普通的`HashMap`是**非线程安全**的。在多线程环境下，可以使用以下几种方式来保证并发安全：
    1.  **`Collections.synchronizedMap(Map)`**： 返回一个由指定Map支持的同步（线程安全）Map。它通过在所有方法上加上`synchronized`关键字来实现，**锁的粒度是整个Map对象**，性能较差。
        ```java
        Map<String, String> syncMap = Collections.synchronizedMap(new HashMap<>());
        ```
    2.  **`ConcurrentHashMap`（推荐）**： 专门为高并发场景设计的线程安全Map。在JDK8中，它使用 **`Node数组 + 链表/红黑树`** 的结构，并通过 **`CAS操作`** 和 **`synchronized`同步代码块（只锁住单个桶的头节点）** 来实现线程安全，**锁的粒度更细，并发性能远高于`Hashtable`和`synchronizedMap`**。

**7. ConcurrentHashMap在JDK8怎么优化？**

*   **答案**： 相对于JDK7的`ConcurrentHashMap`，JDK8进行了重大优化：
    *   **JDK7**： 采用**分段锁（Segment）** 机制。将整个数据分成一段一段（默认为16段），每段持有一把锁。这样不同段的操作可以并行，但同段的操作仍需竞争锁。
    *   **JDK8**： **放弃了分段锁**，采用了更细粒度的锁方案：
        1.  **数据结构与HashMap一致**： 数组 + 链表 / 红黑树。
        2.  **锁的粒度是单个桶（数组元素）**： 使用`synchronized`来锁定当前要操作的桶的头节点（如`Node`, `TreeNode`）。
        3.  **大量使用CAS无锁算法**： 对于数组元素的初始化、扩容时节点的移动等操作，使用CAS来避免加锁，进一步提高并发效率。
        4.  **复杂度降低**： 设计上比分段锁更简洁，并发度更高（理论上最大并发度等于数组长度）。

**8. Arrays工具类和Collection工具类**

*   **答案**：
    *   **`Arrays`工具类**： 提供了操作数组（如排序、搜索、比较、填充）的静态方法。
        *   `Arrays.sort(arr)`： 对数组进行排序（双轴快排）。
        *   `Arrays.binarySearch(arr, key)`： 对已排序数组进行二分查找。
        *   `Arrays.asList(T... a)`： 将数组转换为一个**固定大小的List视图**（注意：此List不支持`add/remove`操作）。
        *   `Arrays.copyOf(original, newLength)`： 复制数组。
        *   `Arrays.toString(arr)` / `Arrays.deepToString(arr)`： 将数组内容转换为字符串。

    *   **`Collections`工具类**： 提供了操作集合（`Collection`）的静态方法。
        *   `Collections.sort(list)` / `Collections.sort(list, comparator)`： 对List进行排序。
        *   `Collections.reverse(list)`： 反转List中元素的顺序。
        *   `Collections.synchronizedList(list)`： 返回一个线程安全的List包装器。
        *   `Collections.unmodifiableList(list)`： 返回一个不可修改的List视图。
        *   `Collections.max(collection)` / `Collections.min(collection)`： 找出集合中的最大/最小值。

---